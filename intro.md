## SERVICE MESH

![image](https://github.com/pavankumar0077/istio-guide/assets/40380941/60582368-cb0f-4e5a-93c6-a26380ec0845)

## REF DOCS == ``` https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ ```

### WHAT IS SERVICE MESH IN KUBERNETES CLUSTER
- SERVICE MESH MANAGES THE TRAFFIC MANAGEMENT IN KUBERNETES CLUSTER SPECIALLY EAST WEST TRAFFIC MANAGEMENT OF K8S CLUSTER.
- TRAFFIC BETWEEN KUBERENTES SERVICES AND CLUSTERS
- 

### EX :
- A E-com application is deployed in kubernetes cluster with 4 microservices (login, catalog, payment, notification)
- LOGIN --> CATALOG --> PAYMENTS --> NOTIFICATIONS
- If this e-com application has to expose to the customers or to the users outside the kubernetes cluster -- A IGRESS IS CREATED OR SERVICE TYPE OF NODEPORT OR LOAD BALANCER TYPE
- user must access the LOGIN microservice outside the KUBERNETES CLUSTER. Only then the e-com application will be able to LOGIN from the user or customers.
- IN THIS WE NEED TO CONTROL THE TRAFFIC -- ONE is traffic comming from the ingress -- that is from the users -- outside the kubernetes cluster ==== THIS IS CALLED NORTH SOUTH GRAPH
- OTHER one is LOGIN TALKING TO THE CATALOG -- AND FLOW GOES --> PAYMENTS --> NOTIFICATIONS, THIS DOESN'T REQUIRED ANY INGRESS OR EGRESS TRAFFIC ==== THIS IS CALLED AS EAST WEST TRAFFIC


### WHY SERVICE MESH
- AS SEEN ABOVE EXAMPLE SERVICE TO SERVICE COMMUNICATION IS POSSIBLE
- BUT ISTIO ENHANCES OR ADDS ON CAPABILITES TO YOUR SERVICE TO SERVICE COMMUNICATION SUCH AS **MUTUAL TLS**
- ISTIO ADDS THE MUTUAL TLS SERVICE TO SERVICE COMMUNICATION, IT ALSO ADDS OTHER CAPABILITES SUCH AS ADVANCED DEPLOY **CANARY/AB/BLUE-GREEN**
- ISTIO COMES WITH OBSERVABILITY IT COMES WITH **KIALI**, IT KEEPS THE TRACK OF YOUR SERVICE TO SERVICE COMMUNICATION 

### WHAT IS MUTUAL TLS
- IF WE INSTALL ISTIO AND ALLOW ISTIO TO A PARTICULAR NAME SPACE THEN ISTIO SAYS IT WILL SECURE SERVICE TO SERVICE COMMUNICATION
- BYDEFAULT THESE SERVICES ARE TALING WITHOUT ANY TLS WITHOUT ANY SECURIY MEASURES
- IF WE NEED INSTALL IT WILL ADD MUTUAL TLS, SO ALL THE 4 MICROSERVICES WILL HAVE TLS CERTIFICATE WHICH WLL BE GIVEN BY CERTICATE AUTHORITY (CA) OF ISTIO
- WHEN LOGIN SERVICE WANTS TO COMMUNICATE WITH CATALOG IT WILL DISPLAY THE CERTIFICATE BOTH DISPLAYS THEIR CERTIFICATES TO EACH OTHER AND ONLY WHEN BOTH OF THEM TRUST EACH OTHER A COMMUNICATION IS ESTABLISHED.
- IN TRADITIONAL TLS APPROACH USUALLY CLIENT IS THE ONE THAT DISPLAYS CERTIFICATE TO THE SERVER AND IF THER SERVER ACKNOWLEGES THEN A TRUST IS ESTABLISTED AND COMMUNICATION IS ESTABLISHED.
- ISTIO IS ADVANCE LEVEL OF TLS
- ISTIO HAS ADVANCE DEPLOYMENT STRATEGIES LIKE CANARY, AB, BLUE - GREEN DEPLOYMENTS IN A VERY EASY WAY

### CANARY DEPLOYMENT
- Catalog C is talking to Payments P -- Assume it as Version v1
- we want to introduce advance future for the payments called P2 as Version V2
- we have tested in testing, dev and other envornments but we are not confident to PUT IN THE PROD for all the customers
- So we can use deplooyment strtegies like Canary where initially you can request your catalog service to ONLY SEND 10% OF TRAFFIC to the new VERSION that is V2, and REST 90% TO V1

## HOW ISTIO WORKS

![image](https://github.com/pavankumar0077/istio-guide/assets/40380941/5dbc8ff8-200e-4b05-9551-f85dc0003d44)

- ISTIO ADDS NEW CONTAINER IN EACH AND EVERY POD, THAT SITS NEXT TO THE ACTUAL CONTAINER
- SIDE-CAR CONTAINER HAS A ENVOY PROXY APPLICATION IT IS A PROXY SERVER, IT HANDLES THE TRAFFIC MANAGEMENT OF KUBERNETES CLUSTER
- ANY REQUEST IN AND OUTSIDE WILL COME AND GO FROM THE SIDE-CAR CONTAINER
- THIS SIDE-CAR CONTAINER IS INSTALLED IN EACH AND EVERY POD OF YOUR KUBERNETS CLUSTER.

### Example :
- We have Catalog C, Payment P, In General without ISTIO what catalog does with requests a API CALL TO PAYMENTS

- WITHOUT SERVICE MESH
- IT uses SERVICE URL OF CATALOG APP, ( iT WILL GET IT FROM CONFIG MAP OR  CATALOG GETS THE SERVICE URL OF PAYMENT FROM THE COMMAND ARGUMENT ANYWAYS IT INITIATE A API REQUEST AND PAYMENT WILL SEND THE RESPONSE.

- WITH SERVICE MESH
- CATALOG TRIES TO INITIATE A API CALL TO THE PAYMENTS, THE REQUEST WILL BE TAKEN BY THE SIDE-CAR CONTAINER THE API CALL IS INTERCEPTED BY THE SIDECAR CONTAINER IT GOES TO THE SIDE-CAR CONTAINER AND FROM THERE IT WILL GO TO THE PAYMENTS AGAIN THE SIDE-CAR CONTAINER IN THE PAYMENTS WILL INTERCEPT THE REQUEST AND THEN IT GOES TO THE PAYMENTS
- BOTH INWARD TRAFFIC AND OUTWARD TRAFFIC IS INTERCEPTED BY THE SIDECAR CONTAINERS.

### ISTIOD
-- IT IS PRIMARY COMPONET OF THE ISTIO IT RECEIVERS ALL THES INFORMATION AND IT KEEPS THE TRACK OF ALL THE SERVICE METRICES WHICH WILL 


### HOW Side-Car Container works ( ADMISSION CONTROLLER)
- IF ISTIO WANTS TO ADD A SIDE-CAR CONTAINER TO EACH AND EVERY POD THAT IS CREATED IN THE KUBERNETES CLUSTER, ISTIO NEEDS TO GET THE INFORMATION FROM SOME WHERE.
- IF SOMEONE SENDS A REQEUST TO API SERVER FOR A POD CREATION ISTIO SHOULD BE IMMEDIATELY NOTIFIED THAT SOMEONE IS REQUESTING ME FOR CREATING A POD DO YOU WANT TO ADD A SIDE-CAR CONATINER TO IT OR NOT.
- IF API SERVER IS NOTIFIYING ISTIO A SIDE-CAR CONTAINER NOT GET CREATED FOR THE POD.
- ISTIO USES ADMISSION CONTROLLER

### ADMISSION CONTROLLER
- ISTIO USES A LITTLE ADVANCE CONCEPT OF DYNAMIC ADMISSION CONTROL OR ADMISSION WEBHOOK
- THERE IS A USER HE WANTS TO CREATE A POD, HE USE KUBECTL APPLY COMMAND AND IT GOES TO API SERVER
- STEP 1 : - THERE A COMPONENT IN THE API SERVER WHICH WILL BASICALLY VERIFY IS THE USER IS AUTHENTICATED AND AUTHORIZED TO PERFORM THE ACTION OR NOT.
- BEFORE API SERVER CREATES THE OBJECTS IN THE ETCD, ADMISSION CONTROLLER WILL COMES IN BETWEEN INTERCEPT AND MUTATE - MODIFY (OR) VALIDATE THE OBJECTS 
- STEP 2 : - IF USER IS AUTH AND AUTHORIZED THEN API SERVER WILL TAKE THIS OBJECT AND PERSISTED THE OBJECT IN THE ETCD OR STORES THE OBJECT IN THE ETCD.
- FOR EXAMPLE
- - You want to create a PVC so the reqeust goes to api server you have authen and author, So api server tries to add that resource to ETCD, before adding there is a admission controller that is called STORAGE CLASS ADMISSION CONTROLLER, Which comes into picture it will see if the PVC has the storage class field or not, if it does not have it will mutate (modify) the object and in the object it will add the field to your PVC creation request mutation admission controller will add a new field and that field is called storage class equals to XYZ and then the object is persisted (stored) into ETCD.
  - Like this we have 30+ admission controllers that are available by default in every kubernetes cluster, Ofcourse sometimes they are disabled by some distributions, And these admission controllers you don't have to install them they are pre-compiled into the API SERVER, SO Api server already has code for all the 30+ admission controllers you can just ENABLE OR DISABLE THEM.
  - REF DOC  === ``` https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/ ```
  
